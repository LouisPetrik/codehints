{
  "pluginId": "default",
  "version": "current",
  "label": "Next",
  "banner": null,
  "badge": false,
  "noIndex": false,
  "className": "docs-version-current",
  "isLast": true,
  "docsSidebars": {
    "tutorialSidebar": [
      {
        "type": "link",
        "label": "Cheatsheets Introduction",
        "href": "/",
        "docId": "intro"
      },
      {
        "type": "category",
        "label": "C++",
        "collapsible": true,
        "collapsed": true,
        "items": [
          {
            "type": "link",
            "label": "Arrays",
            "href": "/cpp/arrays",
            "docId": "cpp/arrays"
          },
          {
            "type": "link",
            "label": "Classes",
            "href": "/cpp/classes",
            "docId": "cpp/classes"
          },
          {
            "type": "link",
            "label": "Functions",
            "href": "/cpp/functions",
            "docId": "cpp/functions"
          },
          {
            "type": "link",
            "label": "Stack, Heap and Static Memory",
            "href": "/cpp/heap-stack-memory",
            "docId": "cpp/heap-stack-memory"
          },
          {
            "type": "link",
            "label": "Pointers",
            "href": "/cpp/pointers",
            "docId": "cpp/pointers"
          },
          {
            "type": "link",
            "label": "References",
            "href": "/cpp/references",
            "docId": "cpp/references"
          },
          {
            "type": "link",
            "label": "Structures",
            "href": "/cpp/structures",
            "docId": "cpp/structures"
          },
          {
            "type": "link",
            "label": "Variables & Data types",
            "href": "/cpp/variables-data-types",
            "docId": "cpp/variables-data-types"
          },
          {
            "type": "link",
            "label": "vectors",
            "href": "/cpp/vectors",
            "docId": "cpp/vectors"
          }
        ],
        "href": "/category/c"
      },
      {
        "type": "category",
        "label": "Go",
        "collapsible": true,
        "collapsed": true,
        "items": [
          {
            "type": "link",
            "label": "Arrays & Slices",
            "href": "/go/arrays-slices",
            "docId": "go/arrays-slices"
          },
          {
            "type": "link",
            "label": "Concurrency",
            "href": "/go/concurrency",
            "docId": "go/concurrency"
          },
          {
            "type": "link",
            "label": "Conditionals",
            "href": "/go/conditionals",
            "docId": "go/conditionals"
          },
          {
            "type": "link",
            "label": "Custom types",
            "href": "/go/custom-types",
            "docId": "go/custom-types"
          },
          {
            "type": "link",
            "label": "Functions",
            "href": "/go/functions",
            "docId": "go/functions"
          },
          {
            "type": "link",
            "label": "Getting started",
            "href": "/go/getting-started",
            "docId": "go/getting-started"
          },
          {
            "type": "link",
            "label": "fmt package (IO)",
            "href": "/go/io",
            "docId": "go/io"
          },
          {
            "type": "link",
            "label": "For Loops",
            "href": "/go/loops",
            "docId": "go/loops"
          },
          {
            "type": "link",
            "label": "Variables",
            "href": "/go/variables",
            "docId": "go/variables"
          }
        ],
        "href": "/category/go"
      },
      {
        "type": "category",
        "label": "PureScript",
        "collapsible": true,
        "collapsed": true,
        "items": [
          {
            "type": "link",
            "label": "Using the console",
            "href": "/purescript/IO",
            "docId": "purescript/IO"
          },
          {
            "type": "link",
            "label": "Arrays in PureScript",
            "href": "/purescript/arrays",
            "docId": "purescript/arrays"
          },
          {
            "type": "link",
            "label": "Bindings",
            "href": "/purescript/bindings",
            "docId": "purescript/bindings"
          },
          {
            "type": "link",
            "label": "Conditionals",
            "href": "/purescript/conditionals",
            "docId": "purescript/conditionals"
          },
          {
            "type": "link",
            "label": "Custom Types",
            "href": "/purescript/custom-types",
            "docId": "purescript/custom-types"
          },
          {
            "type": "link",
            "label": "Folds",
            "href": "/purescript/folds",
            "docId": "purescript/folds"
          },
          {
            "type": "link",
            "label": "Functions",
            "href": "/purescript/functions",
            "docId": "purescript/functions"
          },
          {
            "type": "link",
            "label": "Getting started",
            "href": "/purescript/getting-started",
            "docId": "purescript/getting-started"
          },
          {
            "type": "link",
            "label": "JavaScript Interaction",
            "href": "/purescript/js-interaction",
            "docId": "purescript/js-interaction"
          },
          {
            "type": "link",
            "label": "Lists",
            "href": "/purescript/lists",
            "docId": "purescript/lists"
          },
          {
            "type": "link",
            "label": "Map, Reduce and Filter",
            "href": "/purescript/map-reduce-filter",
            "docId": "purescript/map-reduce-filter"
          },
          {
            "type": "link",
            "label": "Modules",
            "href": "/purescript/modules",
            "docId": "purescript/modules"
          },
          {
            "type": "link",
            "label": "Pattern matching",
            "href": "/purescript/patttern-matching",
            "docId": "purescript/patttern-matching"
          },
          {
            "type": "link",
            "label": "Records",
            "href": "/purescript/records",
            "docId": "purescript/records"
          },
          {
            "type": "link",
            "label": "Standard Library",
            "href": "/purescript/standard-lib",
            "docId": "purescript/standard-lib"
          },
          {
            "type": "link",
            "label": "Typeclasses",
            "href": "/purescript/typeclasses",
            "docId": "purescript/typeclasses"
          },
          {
            "type": "link",
            "label": "Types",
            "href": "/purescript/types",
            "docId": "purescript/types"
          }
        ],
        "href": "/category/purescript"
      },
      {
        "type": "category",
        "label": "Haskell",
        "collapsible": true,
        "collapsed": true,
        "items": [
          {
            "type": "link",
            "label": "In and output",
            "href": "/haskell/IO",
            "docId": "haskell/IO"
          },
          {
            "type": "link",
            "label": "Bindings",
            "href": "/haskell/bindings",
            "docId": "haskell/bindings"
          },
          {
            "type": "link",
            "label": "Data types",
            "href": "/haskell/data-types",
            "docId": "haskell/data-types"
          },
          {
            "type": "link",
            "label": "Functions",
            "href": "/haskell/functions",
            "docId": "haskell/functions"
          },
          {
            "type": "link",
            "label": "GHCI",
            "href": "/haskell/ghci",
            "docId": "haskell/ghci"
          },
          {
            "type": "link",
            "label": "Hello world",
            "href": "/haskell/greeting",
            "docId": "haskell/greeting"
          },
          {
            "type": "link",
            "label": "Lists",
            "href": "/haskell/lists",
            "docId": "haskell/lists"
          },
          {
            "type": "link",
            "label": "Typeclasses",
            "href": "/haskell/typeclasses",
            "docId": "haskell/typeclasses"
          }
        ],
        "href": "/category/haskell"
      },
      {
        "type": "category",
        "label": "WebAssembly",
        "collapsible": true,
        "collapsed": true,
        "items": [
          {
            "type": "link",
            "label": "WebAssembly Text Format (WAT)",
            "href": "/webassembly/wat",
            "docId": "webassembly/wat"
          }
        ],
        "href": "/category/webassembly"
      }
    ]
  },
  "docs": {
    "cpp/arrays": {
      "id": "cpp/arrays",
      "title": "Arrays",
      "description": "An array is a collecting of data, of the same type and with a fixed length.",
      "sidebar": "tutorialSidebar"
    },
    "cpp/classes": {
      "id": "cpp/classes",
      "title": "Classes",
      "description": "By default, all properties of a class are kept private, therefore not visble outside of the scope.",
      "sidebar": "tutorialSidebar"
    },
    "cpp/functions": {
      "id": "cpp/functions",
      "title": "Functions",
      "description": "Terminology:",
      "sidebar": "tutorialSidebar"
    },
    "cpp/heap-stack-memory": {
      "id": "cpp/heap-stack-memory",
      "title": "Stack, Heap and Static Memory",
      "description": "Allocating variables in the memory",
      "sidebar": "tutorialSidebar"
    },
    "cpp/pointers": {
      "id": "cpp/pointers",
      "title": "Pointers",
      "description": "A pointer is an integer, which stores a memory address. Types can be used with pointers but more on a syntactical-level to make clear what the value retrieved will be.",
      "sidebar": "tutorialSidebar"
    },
    "cpp/references": {
      "id": "cpp/references",
      "title": "References",
      "description": "References are related to pointers - one needs to understand the first one. They work similary like pointers.",
      "sidebar": "tutorialSidebar"
    },
    "cpp/structures": {
      "id": "cpp/structures",
      "title": "Structures",
      "description": "Through structures, multiple values can be grouped together.",
      "sidebar": "tutorialSidebar"
    },
    "cpp/variables-data-types": {
      "id": "cpp/variables-data-types",
      "title": "Variables & Data types",
      "description": "Strings",
      "sidebar": "tutorialSidebar"
    },
    "cpp/vectors": {
      "id": "cpp/vectors",
      "title": "vectors",
      "description": "Dynamic arrays (std::vector)",
      "sidebar": "tutorialSidebar"
    },
    "go/arrays-slices": {
      "id": "go/arrays-slices",
      "title": "Arrays & Slices",
      "description": "Arrays",
      "sidebar": "tutorialSidebar"
    },
    "go/concurrency": {
      "id": "go/concurrency",
      "title": "Concurrency",
      "description": "In this example, there will never be \"fish\" printed.",
      "sidebar": "tutorialSidebar"
    },
    "go/conditionals": {
      "id": "go/conditionals",
      "title": "Conditionals",
      "description": "You can declare variables even within the if-syntax:",
      "sidebar": "tutorialSidebar"
    },
    "go/custom-types": {
      "id": "go/custom-types",
      "title": "Custom types",
      "description": "Thanks to custom types, we can create functions, so called receiver-functions, that do only work with the certain type, we created. A custom type is therefore just a fancy replacement for a base type, not something completely new.",
      "sidebar": "tutorialSidebar"
    },
    "go/functions": {
      "id": "go/functions",
      "title": "Functions",
      "description": "Since Go is a compiled language, we can write the function that should be executed, after the calling function. No problem.",
      "sidebar": "tutorialSidebar"
    },
    "go/getting-started": {
      "id": "go/getting-started",
      "title": "Getting started",
      "description": "app.go",
      "sidebar": "tutorialSidebar"
    },
    "go/io": {
      "id": "go/io",
      "title": "fmt package (IO)",
      "description": "fmt is a default package, used for IO. It stands for \"format\".",
      "sidebar": "tutorialSidebar"
    },
    "go/loops": {
      "id": "go/loops",
      "title": "For Loops",
      "description": "For-Loops are the only loops which can be used in Go.",
      "sidebar": "tutorialSidebar"
    },
    "go/variables": {
      "id": "go/variables",
      "title": "Variables",
      "description": "Go is statically typed. That means, once we chose a datatype, we must keep the value aligned to it.",
      "sidebar": "tutorialSidebar"
    },
    "haskell/bindings": {
      "id": "haskell/bindings",
      "title": "Bindings",
      "description": "Bindings can be seen as a replacement for constants in the scope of functions. They don't enable us to do something completely new, but help to make things more clearly, as we can store the result of some expression through a binding.",
      "sidebar": "tutorialSidebar"
    },
    "haskell/data-types": {
      "id": "haskell/data-types",
      "title": "Data types",
      "description": "Int & Integer",
      "sidebar": "tutorialSidebar"
    },
    "haskell/functions": {
      "id": "haskell/functions",
      "title": "Functions",
      "description": "Chapter will be more complete soon. For now, check out the Functions cheatsheet of PureScript as functions work the same way in Haskell.",
      "sidebar": "tutorialSidebar"
    },
    "haskell/ghci": {
      "id": "haskell/ghci",
      "title": "GHCI",
      "description": "The Glasgow Haskell compiler",
      "sidebar": "tutorialSidebar"
    },
    "haskell/greeting": {
      "id": "haskell/greeting",
      "title": "Hello world",
      "description": "",
      "sidebar": "tutorialSidebar"
    },
    "haskell/IO": {
      "id": "haskell/IO",
      "title": "In and output",
      "description": "When initialising records for example, you might have noticed that you are unable to print",
      "sidebar": "tutorialSidebar"
    },
    "haskell/lists": {
      "id": "haskell/lists",
      "title": "Lists",
      "description": "Accessing element in list through index:",
      "sidebar": "tutorialSidebar"
    },
    "haskell/typeclasses": {
      "id": "haskell/typeclasses",
      "title": "Typeclasses",
      "description": "When asking GHCI for the type of an operator like the plus-operator, you will notice that it is basically a function. Everything before the => sign is called the class constraint.",
      "sidebar": "tutorialSidebar"
    },
    "intro": {
      "id": "intro",
      "title": "Cheatsheets Introduction",
      "description": "Hey there! Welcome to my cheatsheets",
      "sidebar": "tutorialSidebar"
    },
    "purescript/arrays": {
      "id": "purescript/arrays",
      "title": "Arrays in PureScript",
      "description": "Generating Array in Range:",
      "sidebar": "tutorialSidebar"
    },
    "purescript/bindings": {
      "id": "purescript/bindings",
      "title": "Bindings",
      "description": "Many ask, whether it's in the style of functional programming to declare and mutate variables within the scope of a function. If you have a couple hours left, go ahead and Google the discussion yourself. Meanwhile, in PureScript we can assign constants within the scope of a function. This can be done with bindings.",
      "sidebar": "tutorialSidebar"
    },
    "purescript/conditionals": {
      "id": "purescript/conditionals",
      "title": "Conditionals",
      "description": "There are a couple ways to execute code conditionally in PureScript: If-then-else, case expressions, pattern matching (there is a whole section below on this topic) and guards.",
      "sidebar": "tutorialSidebar"
    },
    "purescript/custom-types": {
      "id": "purescript/custom-types",
      "title": "Custom Types",
      "description": "Creating data types and re-naming types is powerful. To achieve both things, PureScript offers two keywords:",
      "sidebar": "tutorialSidebar"
    },
    "purescript/folds": {
      "id": "purescript/folds",
      "title": "Folds",
      "description": "Make sure to import:",
      "sidebar": "tutorialSidebar"
    },
    "purescript/functions": {
      "id": "purescript/functions",
      "title": "Functions",
      "description": "As the name of functional programming suggests it, this style of writing code resolves all around writing functions - so, let's cover what you need to know.",
      "sidebar": "tutorialSidebar"
    },
    "purescript/getting-started": {
      "id": "purescript/getting-started",
      "title": "Getting started",
      "description": "Installing PureScript on your machine:",
      "sidebar": "tutorialSidebar"
    },
    "purescript/IO": {
      "id": "purescript/IO",
      "title": "Using the console",
      "description": "To log something in the console, make sure to import the proper package.",
      "sidebar": "tutorialSidebar"
    },
    "purescript/js-interaction": {
      "id": "purescript/js-interaction",
      "title": "JavaScript Interaction",
      "description": "This part resolves around using PureScript functions in JavaScript, and the other way around - using JavaScript functions in",
      "sidebar": "tutorialSidebar"
    },
    "purescript/lists": {
      "id": "purescript/lists",
      "title": "Lists",
      "description": "In PureScript it is important to differentiate Lists and Arrays.",
      "sidebar": "tutorialSidebar"
    },
    "purescript/map-reduce-filter": {
      "id": "purescript/map-reduce-filter",
      "title": "Map, Reduce and Filter",
      "description": "Map",
      "sidebar": "tutorialSidebar"
    },
    "purescript/modules": {
      "id": "purescript/modules",
      "title": "Modules",
      "description": "Modules are the way to split up our code into multiple files. Here is an example of writing a function in",
      "sidebar": "tutorialSidebar"
    },
    "purescript/patttern-matching": {
      "id": "purescript/patttern-matching",
      "title": "Pattern matching",
      "description": "Before, we just covered a little bit of pattern matching in functions - let's go into more detail, and learn about pattern matching for different data types.",
      "sidebar": "tutorialSidebar"
    },
    "purescript/records": {
      "id": "purescript/records",
      "title": "Records",
      "description": "Records are basically like Objects in JS. Yet, immutable, of course.",
      "sidebar": "tutorialSidebar"
    },
    "purescript/standard-lib": {
      "id": "purescript/standard-lib",
      "title": "Standard Library",
      "description": "This section is going to cover some useful functions, available by default, like const, apply, flip and more.",
      "sidebar": "tutorialSidebar"
    },
    "purescript/typeclasses": {
      "id": "purescript/typeclasses",
      "title": "Typeclasses",
      "description": "No, typeclasses are not related to classes in object oriented programming. Rather, typeclasses can be imagined as interfaces in functional programming. Typeclasses serve to overload functions for different data types, for example. First, we define the class itself and the signature of the functions it holds. Then, we can create as many instances as we like to - these instances are usually created for different data types. Nevertheless, all instances must define the functions which are declared in the related typeclass. Let's look at an example.",
      "sidebar": "tutorialSidebar"
    },
    "purescript/types": {
      "id": "purescript/types",
      "title": "Types",
      "description": "Default Types",
      "sidebar": "tutorialSidebar"
    },
    "webassembly/wat": {
      "id": "webassembly/wat",
      "title": "WebAssembly Text Format (WAT)",
      "description": "WA offers a notation which can be used to write human-readable code, compiled to WASM.",
      "sidebar": "tutorialSidebar"
    }
  }
}