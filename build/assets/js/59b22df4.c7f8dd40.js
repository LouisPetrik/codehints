"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[7993],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),u=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(o.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,o=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),h=u(n),d=r,m=h["".concat(o,".").concat(d)]||h[d]||p[d]||s;return n?a.createElement(m,l(l({ref:t},c),{},{components:n})):a.createElement(m,l({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,l=new Array(s);l[0]=h;var i={};for(var o in t)hasOwnProperty.call(t,o)&&(i[o]=t[o]);i.originalType=e,i.mdxType="string"==typeof e?e:r,l[1]=i;for(var u=2;u<s;u++)l[u]=n[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},4715:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>u});var a=n(7462),r=(n(7294),n(3905));const s={},l="Data types",i={unversionedId:"haskell/datatypes",id:"haskell/datatypes",title:"Data types",description:"Int & Integer",source:"@site/docs/haskell/datatypes.md",sourceDirName:"haskell",slug:"/haskell/datatypes",permalink:"/docs/haskell/datatypes",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/haskell/datatypes.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Translate your site",permalink:"/docs/tutorial-extras/translate-your-site"},next:{title:"Functions",permalink:"/docs/haskell/functions"}},o={},u=[{value:"Int &amp; Integer",id:"int--integer",level:3},{value:"Char &amp; String",id:"char--string",level:3},{value:"Tuples",id:"tuples",level:3},{value:"Enums",id:"enums",level:3},{value:"Type variables",id:"type-variables",level:3},{value:"Using type parameters",id:"using-type-parameters",level:3},{value:"Deriving instances",id:"deriving-instances",level:3}],c={toc:u};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"data-types"},"Data types"),(0,r.kt)("h3",{id:"int--integer"},"Int & Integer"),(0,r.kt)("p",null,'While "Int" is the classic integer type bound to a size, so limited in the number of numbers it can represent, "Integer" is not bound - yet, "Int" is more efficient. '),(0,r.kt)("h3",{id:"char--string"},"Char & String"),(0,r.kt)("p",null,"A char is a single character. A string is technically an array of chars, which is why strings are often noted as ","[Char]",' in Haskell. Nevertheless, we can also use "String". '),(0,r.kt)("h3",{id:"tuples"},"Tuples"),(0,r.kt)("p",null,"Unlike lists, tuples can hold different types of data. "),(0,r.kt)("p",null,'We speak of pairs if a tuple has exactly two elements (no-brainer.)\nFunction we can use on tuple pairs are fst "first" and snd "second": '),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"fst (1, 2)\n--- 1\n\nsnd (1, 2)\n--- 2\n")),(0,r.kt)("p",null,"Tuples can be returned from functions directly: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"returnTuple :: Int -> Int -> (Int, Int)\nreturnTuple x y = (x, y)\n")),(0,r.kt)("p",null,"This function just takes two values and puts them into a tuple. "),(0,r.kt)("h3",{id:"enums"},"Enums"),(0,r.kt)("p",null,"Enum stands for enumeration, and might be known from many other programming languages. "),(0,r.kt)("p",null,"Creating a custom enumeration: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Numbers = One | Two | Three | Four | Five | Six\n  deriving (Eq, Ord, Show, Read, Bounded, Enum)\n")),(0,r.kt)("p",null,"Ignore the deriving-stuff for a moment. It just enables us to use a lot of functions on this type of data. When opening up the console, you can now see, that we have an ordered enumeration: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"One > Two \nFalse \n\nTwo > One \nTrue\n\nminBound :: Numbers \nOne \n\nsucc One \nTwo \n")),(0,r.kt)("p",null,"More on the deriving-syntax ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/LouisPetrik/cheatsheet/blob/master/haskell.md#deriving-instances"},"here")),(0,r.kt)("p",null,"Types always start with an uppercase letter. "),(0,r.kt)("h3",{id:"type-variables"},"Type variables"),(0,r.kt)("p",null,"Often you will see function signatures like this one: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"head :: [a] -> a\n")),(0,r.kt)("p",null,"Notice the a? While the ","[a]"," surely stands for a list, a itself can be anything when it comes to types. Therefore the head function can take a list of chars, strings, integers and return a single element of the same type. a is a type variable. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'data Person = Person String Int\n\njohn = Person "John" 20\n')),(0,r.kt)("p",null,'You might wonder why there is a second "Person" on the right side of the equals sign - yet, john would looks like this in JavaScript: '),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'const john = new Person("John", 22);\n')),(0,r.kt)("p",null,'"Person" in the right side of the equals sign is called the data-constructor. '),(0,r.kt)("p",null,"For better understanding: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Name = Lastname String | Firstname String\n")),(0,r.kt)("p",null,'In fact, Lastname and Firstname are both available now as types - we can assign them to functions, constants etc. Once we did so, the values are also of the type "Name".\nNow, you might understand better what we mean with data constructors - Lastname and Firstname in this case. That\'s why in the above example of Person, Person is also used the data constructor - there is no subtype belonging to it. '),(0,r.kt)("p",null,"Using custom data in functions: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Name = Lastname String | Firstname String\n\ngreetWithFirstname :: Name -> String\ngreetWithFirstname (Firstname name) = name\n")),(0,r.kt)("p",null,"And calling the function: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'greetWithFirstname (Firstname "Max")\n"Max"\n')),(0,r.kt)("p",null,"In the type declaration, you can see that we use Name as the first parameter - not Firstname, which the function actually wants to use. The reason is, that Firstname is a constructor - not a type. Name is the type, and in the function declaration, types are needed. "),(0,r.kt)("h3",{id:"using-type-parameters"},"Using type parameters"),(0,r.kt)("p",null,"As we covered data constructors before, we can now move on to types parameters. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Maybe a = Nothing | Just a \n")),(0,r.kt)("p",null,'In this example, a is a type parameter. Maybe on the other hand, is the type constructor.\nWhy Maybe is a type constructor, might be more clearly when interacting with the parameter. We can pass almost anything into a, resulting in a "Maybe String", "Maybe Char", "Maybe Person" etc. The values themselves can never just have a type of only Maybe, since Maybe is a constructor, not an actual type. '),(0,r.kt)("p",null,"To make it even more clear, when we pass String to Maybe, the resulting type will be Maybe String. On the other hand, Just 'Hello World' has a type of Maybe ","[Char]",". "),(0,r.kt)("p",null,'Important to understand is also, that the type of "Nothing" is "Maybe a". Therefore, we can pass Nothing to each function requiring a "Maybe x" (String, Integer etc.). '),(0,r.kt)("h3",{id:"deriving-instances"},"Deriving instances"),(0,r.kt)("p",null,"In Haskell, we can force our data type to be derived of a certain typeclass. We will see in a second what this means.\nHere is an example. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Person = Person {\n  firstname: String, \n  lastname: String\n} deriving (Eq)\n")),(0,r.kt)("p",null,'Now, let\'s create two people of the data type "Person": '),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'maxi :: Person\nmaxi = Person {firstname = "Max", lastname = "Meyer"}\n\ncarl :: Person\ncarl = Person {firstname = "Carl", lastname = "Johnson"}\n')),(0,r.kt)("p",null,'Thanks to deriving the Eq-class which is used for equality-checking and related stuff, we can check whether two people of type "Person" are equal: '),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"maxi == carl \nFalse \n")),(0,r.kt)("p",null,"When trying to show a Person in the console, you will initially fail - yet, it is another problem to be solved with deriving a typeclass. All we need to do is deriving the show-typeclass, too: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Person = Person {\n  firstname: String, \n  lastname: String\n} deriving (Eq)\n")))}p.isMDXComponent=!0}}]);