"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[9932],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>d});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},g=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),g=c(t),d=r,m=g["".concat(s,".").concat(d)]||g[d]||p[d]||i;return t?a.createElement(m,o(o({ref:n},u),{},{components:t})):a.createElement(m,o({ref:n},u))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=g;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var c=2;c<i;c++)o[c]=t[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}g.displayName="MDXCreateElement"},8553:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var a=t(7462),r=(t(7294),t(3905));const i={},o="Basics",l={unversionedId:"golang/basics",id:"golang/basics",title:"Basics",description:"Overview / Table of contents",source:"@site/docs/golang/basics.md",sourceDirName:"golang",slug:"/golang/basics",permalink:"/docs/golang/basics",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/golang/basics.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Go",permalink:"/docs/category/go"},next:{title:"Tutorial - Basics",permalink:"/docs/category/tutorial---basics"}},s={},c=[{value:"Overview / Table of contents",id:"overview--table-of-contents",level:2},{value:"Getting started",id:"getting-started",level:2},{value:"Hello world",id:"hello-world",level:3},{value:"code - app.go",id:"code---appgo",level:4},{value:"executing it",id:"executing-it",level:4},{value:"What are packages?",id:"what-are-packages",level:2},{value:"Variables",id:"variables",level:2},{value:"short declaring",id:"short-declaring",level:3},{value:"var keyword for declaring",id:"var-keyword-for-declaring",level:3},{value:"const keyword for declaring",id:"const-keyword-for-declaring",level:3},{value:"Functions",id:"functions",level:2},{value:"Calling Functions from other files",id:"calling-functions-from-other-files",level:3},{value:"For Loops",id:"for-loops",level:2},{value:"Conditionals",id:"conditionals",level:2},{value:"fmt package",id:"fmt-package",level:2},{value:"Arrays",id:"arrays",level:2},{value:"Slices",id:"slices",level:2},{value:"Custom types",id:"custom-types",level:2},{value:"Receiver Functions",id:"receiver-functions",level:3},{value:"Concurrency",id:"concurrency",level:2},{value:"Wait Groups",id:"wait-groups",level:3}],u={toc:c};function p(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"basics"},"Basics"),(0,r.kt)("h2",{id:"overview--table-of-contents"},"Overview / Table of contents"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("h3",{parentName:"li",id:"go"},(0,r.kt)("a",{parentName:"h3",href:"https://github.com/LouisPetrik/cheatsheet/blob/master/go.md"},"Go"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("h3",{parentName:"li",id:"haskell"},(0,r.kt)("a",{parentName:"h3",href:"https://github.com/LouisPetrik/cheatsheet/blob/master/haskell.md"},"Haskell"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("h3",{parentName:"li",id:"purescript"},(0,r.kt)("a",{parentName:"h3",href:"https://github.com/LouisPetrik/cheatsheet/blob/master/purescript.md"},"PureScript"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("h3",{parentName:"li",id:"c"},(0,r.kt)("a",{parentName:"h3",href:"https://github.com/LouisPetrik/cheatsheet/blob/master/cpp.md"},"C++"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("h3",{parentName:"li",id:"c-1"},(0,r.kt)("a",{parentName:"h3",href:"https://github.com/LouisPetrik/cheatsheet/blob/master/c.md"},"C"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("h3",{parentName:"li",id:"typescript"},(0,r.kt)("a",{parentName:"h3",href:"https://github.com/LouisPetrik/cheatsheet/blob/master/typescript.md"},"TypeScript"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("h3",{parentName:"li",id:"assemblyscript"},(0,r.kt)("a",{parentName:"h3",href:"https://github.com/LouisPetrik/cheatsheet/blob/master/assemblyscript.md"},"AssemblyScript")))),(0,r.kt)("h2",{id:"getting-started"},"Getting started"),(0,r.kt)("h3",{id:"hello-world"},"Hello world"),(0,r.kt)("h4",{id:"code---appgo"},"code - app.go"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'package main // a package must be defined\n\nimport "fmt"\n\nfunc main() {\n  fmt.Println("Hello World!")\n}\n')),(0,r.kt)("h4",{id:"executing-it"},"executing it"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"go run app.go\ngo build app.go\n./app.go\n")),(0,r.kt)("h2",{id:"what-are-packages"},"What are packages?"),(0,r.kt)("p",null,'A package is a collection of code. Package = Project = Workspace.\nOne app means, only one package name.\nThe package name "main" is used to make executables. When using everything else as a name, the compiler would not spit out an executable file. Everything else are so-called reusables.\nEvery file with package main, must have a main-function.'),(0,r.kt)("h2",{id:"variables"},"Variables"),(0,r.kt)("p",null,"Go is statically typed. That means, once we chose a datatype, we must keep the value aligned to it."),(0,r.kt)("h3",{id:"short-declaring"},"short declaring"),(0,r.kt)("p",null,"This works inside of functions"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func main() {\n   name := "Max"\n   fmt.Println(name)\n}\n')),(0,r.kt)("h3",{id:"var-keyword-for-declaring"},"var keyword for declaring"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'var name string = "Max"\nvar age = 23\n// declaring more than one variable:\nvar name, age = "Max", 23\n\nfunc main() {\n   fmt.Println(name)\n   fmt.Println(age)\n}\n')),(0,r.kt)("p",null,"It is not needed to provide the datatype when declaring."),(0,r.kt)("h3",{id:"const-keyword-for-declaring"},"const keyword for declaring"),(0,r.kt)("p",null,"with const constant variables can be declared. It works the same way as var."),(0,r.kt)("p",null,"To sum up, we can keep in mind, that datatype but also the variable type are optional. Go uses inference to pick the right types."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'var name string = "Max"\n// just the same in short:\nname := "Max"\n')),(0,r.kt)("p",null,'Keep in mind, that "=" is only used for reassining.'),(0,r.kt)("h2",{id:"functions"},"Functions"),(0,r.kt)("p",null,"Since Go is a compiled language, we can write the function that should be executed, after the calling function. No problem."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func main() {\n   greet()\n}\n\nfunc greet() {}\n")),(0,r.kt)("p",null,"For the return-statement, we MUST define a datatype."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func greet() string {\n   return "Hi max"\n}\n')),(0,r.kt)("h3",{id:"calling-functions-from-other-files"},"Calling Functions from other files"),(0,r.kt)("p",null,"main.go:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport "fmt"\n\nfunc main() {\n   greet()\n}\n')),(0,r.kt)("p",null,"person.go:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport "fmt"\n\nfunc greet() {\n   fmt.Println("Hey Max")\n}\n')),(0,r.kt)("p",null,"Both need to have the package main. The trick is now, to run both files, leading to main.go can access what is inside of person.go"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"go run main.go person.go\n\ngo build main.go person.go\n")),(0,r.kt)("h2",{id:"for-loops"},"For Loops"),(0,r.kt)("p",null,"For-Loops are the only loops which can be used in Go."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func main() {\n  for i := 0; i <= 3; i++ {\n    fmt.Println(i) // 0, 1, 2, 3\n  }\n}\n")),(0,r.kt)("p",null,"Using an already existing variable: (I did not find a better way, scoping seems to be strange)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"i := 0\nfor i := i; i <= 3; i++ {\n   fmt.Println(i)\n}\n")),(0,r.kt)("h2",{id:"conditionals"},"Conditionals"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'if true == true {\n   fmt.Print("Fucking true")\n} else {\n   fmt.Print("Not.")\n}\n')),(0,r.kt)("p",null,"You can declare variables even within the if-syntax:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'if age := 9; age < 18 {\n   fmt.Print("Not grown up")\n}\n')),(0,r.kt)("p",null,"When using this way to quickly declare a variable, the variable is not available outside of the if-statement."),(0,r.kt)("h2",{id:"fmt-package"},"fmt package"),(0,r.kt)("p",null,'fmt is a default package, used for IO. It stands for "format".'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"fmt.Println()\nfmt.Printf()\nfmt.Print()\n")),(0,r.kt)("p",null,"Both functions from this package can be used to print something on the console.\nPrintln() does a linebreak after printing, Printf() does not.\nPrintf() is for formatting strings."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'a := 5\nb := 10\nfmt.Println(a, "Numbers", b) // \'5 Numbers 10\'\nfmt.Printf(a, "Numbers", b)  // error - variables are not a string\n')),(0,r.kt)("h2",{id:"arrays"},"Arrays"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func main() {\n   // creates an empty array with 5 elements of the type string\n   var names [3]string\n   fmt.Println(names) // [  ]\n}\n")),(0,r.kt)("p",null,"Whitespaces when printing the empty array will indicate the number of elements, the array is made for.\nNo joke."),(0,r.kt)("h2",{id:"slices"},"Slices"),(0,r.kt)("p",null,"Arrays have a fixed length of elements, a slice can grow and shrink. They can only hold data of the same type."),(0,r.kt)("p",null,"This is how we can create a slice, holding data of the type string:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func main() {\n   cards := []string{"First", "Second"}\n   fmt.Println(cards)    // [First Second]\n   fmt.Println(cards[0]) // First\n}\n')),(0,r.kt)("p",null,"Let's add something to the slice:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'cards := []string{"First", "Second"}\ncards = append(cards, "Third")\n')),(0,r.kt)("p",null,"The append-function does not modify the existing slice - it returns a new one."),(0,r.kt)("p",null,"Looping through that slice with the for-loop:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func main() {\n   cards := []string{newCard(), newCard()}\n   cards = append(cards, "Six of spades")\n\n   for i, card := range cards {\n      fmt.Println(i, card)\n   }\n}\n')),(0,r.kt)("p",null,"we can also do it like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"for i := range cards {\n   fmt.Println(cards[i])\n}\n")),(0,r.kt)("h2",{id:"custom-types"},"Custom types"),(0,r.kt)("p",null,"Thanks to custom types, we can create functions, so called receiver-functions, that do only work with the certain type, we created. A custom type is therefore just a fancy replacement for a base type, not something completely new."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'students := []string{"Max", "Anna"}\n')),(0,r.kt)("p",null,"This is how we can create a simple slice of stundents - but we can make things easier, and create one type for it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'type people []string\nstudents := people{"Max", "Anna"}\n')),(0,r.kt)("h3",{id:"receiver-functions"},"Receiver Functions"),(0,r.kt)("p",null,"We can combine custom types with so called receiver functions. Their syntax is a little bit weird."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"")),(0,r.kt)("h2",{id:"concurrency"},"Concurrency"),(0,r.kt)("p",null,'In this example, there will never be "fish" printed.\nCode will print sheep forever, because Go is blocking.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'\nfunc main() {\n   count("sheep")\n   count("fish")\n}\n\nfunc count(thing string) {\n   for i := 1; true; i++ {\n      fmt.Println(i, thing)\n   }\n}\n')),(0,r.kt)("p",null,"We can create a go-routine, making the function execute at the same time with the go-keyword.\nNow both will be executed, sheep, fish, sheep and so on."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func main() {\n   go count("sheep")\n   count("fish")\n}\n')),(0,r.kt)("p",null,"When we make both functions a go-routine, the programm will finish instantly. Why? Because the go-routine takes the function into the background, and then continues to execute the code below.\nWhen the second count() function also is a go routine, the main function is done."),(0,r.kt)("p",null,"We can avoid this by setting a Sleep or wait for userinput. Such code will block the further execution. In this example, sheep and fish will be printed for 2 seconds, then the code stops."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func main() {\n   go count("sheep")\n   go count("fish")\n   time.Sleep(time.Second * 2)\n}\n')),(0,r.kt)("h3",{id:"wait-groups"},"Wait Groups"),(0,r.kt)("p",null,"A wait group is the count of go routines, that should be executed in the code. They help us to manage all the ones running, and can be used to avoid the programming breaking before it should stop.\nHere is a good example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'import (\n   "fmt"\n   "sync"\n   "time"\n)\n\nfunc main() {\n   var wg sync.WaitGroup\n   wg.Add(1)\n\n   go func() {\n      countFish("Fish")\n\n      wg.Done()\n   }()\n\n   go func() {\n      countSheep("Sheep")\n   }()\n\n   wg.Wait()\n}\n\n\nfunc countFish(thing string) {\n   for i := 1; i <= 5; i++ {\n      fmt.Println(i, thing)\n      time.Sleep(time.Millisecond * 500)\n   }\n}\n\nfunc countSheep(thing string) {\n   for i := 1; i <= 10; i++ {\n      fmt.Println(i, thing)\n      time.Sleep(time.Millisecond * 500)\n   }\n}\n')),(0,r.kt)("p",null,"countFish is only executed 5 times. Since both function executions are go-routines, but we said that there is only one routine in the code, the wg.done() will decrease the waiting-counter. Therefore, after countFish is done, the main-functions ends, the programm is done - but Sheep is only printed 6 times till then, even though, we want to run it till i <= 10."),(0,r.kt)("p",null,"To avoid this, we can must count countSheep as a routine in the waiting ones too:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func main() {\n   var wg sync.WaitGroup\n   wg.Add(2)\n\n   go func() {\n      countFish("Fish")\n      wg.Done()\n   }()\n\n   go func() {\n      countSheep("Sheep")\n      wg.Done()\n   }()\n\n   wg.Wait()\n}\n')),(0,r.kt)("p",null,"Now, when countFish is done, the couter still has 1 as value, so waits until countSheep is done too."))}p.isMDXComponent=!0}}]);