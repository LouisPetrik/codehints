"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[5061],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=o.createContext({}),u=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=u(e.components);return o.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),p=u(n),h=a,f=p["".concat(s,".").concat(h)]||p[h]||d[h]||r;return n?o.createElement(f,l(l({ref:t},c),{},{components:n})):o.createElement(f,l({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,l=new Array(r);l[0]=p;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:a,l[1]=i;for(var u=2;u<r;u++)l[u]=n[u];return o.createElement.apply(null,l)}return o.createElement.apply(null,n)}p.displayName="MDXCreateElement"},3289:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>u});var o=n(7462),a=(n(7294),n(3905));const r={},l="Functions",i={unversionedId:"haskell/functions",id:"haskell/functions",title:"Functions",description:"Second title",source:"@site/docs/haskell/functions.md",sourceDirName:"haskell",slug:"/haskell/functions",permalink:"/docs/haskell/functions",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/haskell/functions.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Data types",permalink:"/docs/haskell/datatypes"},next:{title:"ghci",permalink:"/docs/haskell/ghci"}},s={},u=[{value:"Second title",id:"second-title",level:2},{value:"1",id:"1",level:3},{value:"2",id:"2",level:3},{value:"Third",id:"third",level:2},{value:"Yes",id:"yes",level:3},{value:"Function composition",id:"function-composition",level:3},{value:"$ (Dollar sign notation)",id:"-dollar-sign-notation",level:3},{value:". (Dot notation)",id:"-dot-notation",level:3},{value:"Working with typeclasses as function parameters.",id:"working-with-typeclasses-as-function-parameters",level:3},{value:"Bindings",id:"bindings",level:2},{value:"let binding",id:"let-binding",level:3},{value:"where binding",id:"where-binding",level:3}],c={toc:u};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"functions"},"Functions"),(0,a.kt)("h2",{id:"second-title"},"Second title"),(0,a.kt)("h3",{id:"1"},"1"),(0,a.kt)("h3",{id:"2"},"2"),(0,a.kt)("h2",{id:"third"},"Third"),(0,a.kt)("h3",{id:"yes"},"Yes"),(0,a.kt)("p",null,"Chapter will be more complete soon. For now, check out the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/LouisPetrik/cheatsheet/blob/master/purescript.md#functions-1"},"Functions cheatsheet of PureScript")," as functions work the same way in Haskell. "),(0,a.kt)("h3",{id:"function-composition"},"Function composition"),(0,a.kt)("p",null,"The art of letting functions work together, so for example f1(f2(x)) is called function composition.\nThere are two important signs you should know in Haskell. "),(0,a.kt)("p",null,"In fact, composing functions like f1(f2(f3(x))) isn't a technical problem - yet is not that pretty.\nIn Haskell, the $ and . notation offer some syntactial sugar. "),(0,a.kt)("h3",{id:"-dollar-sign-notation"},"$ (Dollar sign notation)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-haskell"},"double :: Int -> Int\ndouble x = x * 2\n\ntriple :: Int -> Int\ntriple x = x * 3\n\n-- possible: \ndouble (triple 2)\n\n-- cleaner: \ndouble $ triple 2\n")),(0,a.kt)("p",null,"As you can see, the $ notation saves us the parentheses, and even provides for the closing one. Instead of having nested parentheses, your code might look more like this: "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-haskell"},"f1 $ f2 $ f3 $ f4 69 \n")),(0,a.kt)("h3",{id:"-dot-notation"},". (Dot notation)"),(0,a.kt)("p",null,"The . operator helps us to tie the result of a function on the right side, to the input on the left side. "),(0,a.kt)("p",null,"Back to our example: "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-haskell"},"-- before: \ndouble $ triple 2\n\n-- now: \n(double . triple) 2\n")),(0,a.kt)("p",null,"To divide our almost final result by two: "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-haskell"},"(divideByTwo . double . triple) 2\n")),(0,a.kt)("p",null,"I guess you now have a good feeling for both operators. "),(0,a.kt)("h3",{id:"working-with-typeclasses-as-function-parameters"},"Working with typeclasses as function parameters."),(0,a.kt)("p",null,"Usually, we strictly define the types of values our function should take and return in the function declaration: "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-haskell"},"add :: Int -> Int -> Int \nadd x y = x + y \n")),(0,a.kt)("p",null,"Yet, sometimes we want to use a broader spectrum of types that might be applied to our function. Coming back to the add-function, we must keep in mind that not just integer-values can be added. To make our function more general, we can instead of mentioning single types, use the whole class: "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-haskell"},"add2 :: Num x => x -> x -> x\nadd2 x y = x + y\n")),(0,a.kt)("p",null,'Now we can even execute "add 2 2.5" succesfully. '),(0,a.kt)("h2",{id:"bindings"},"Bindings"),(0,a.kt)("p",null,"Bindings can be seen as a replacement for constants in the scope of functions. They don't enable us to do something completely new, but help to make things more clearly, as we can store the result of some expression through a binding. "),(0,a.kt)("h3",{id:"let-binding"},"let binding"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-haskell"},"abstractCalculation :: Int -> Int -> Int\nabstractCalculation x y =\n  let sum = x + y\n      product = x * y\n   in sum + product\n")),(0,a.kt)("p",null,'The function above adds the sum of x & y to their product - nothing special. As you can see, with the let-block we can define constants (sum and product) and close the function with the "in" keyword, which kind of serves as return-statement. Hint: You are not forced to use the defined constants within the in-line. '),(0,a.kt)("h3",{id:"where-binding"},"where binding"),(0,a.kt)("p",null,"Using the where keyword we can declare a constant on top of our function which is later initialized. Finally, this constant will be returned from the function. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-haskell"},"addNums :: Int -> Int -> Int\naddNums x y = sum\n  where\n    sum = x + y\n")),(0,a.kt)("p",null,"Yet, this is not a practical usecase for where. More common is to declare your constant as a complex type like a list or a tuple, and then return it. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-haskell"},"sumAndProduct :: Int -> Int -> (Int, Int)\nsumAndProduct x y = (sum, product)\n  where\n    sum = x + y\n    product = x * y\n")))}d.isMDXComponent=!0}}]);