"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[8010],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>d});var r=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function u(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=r.createContext({}),l=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},c=function(e){var n=l(e.components);return r.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},f=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,c=u(e,["components","mdxType","originalType","parentName"]),f=l(t),d=i,h=f["".concat(s,".").concat(d)]||f[d]||p[d]||o;return t?r.createElement(h,a(a({ref:n},c),{},{components:t})):r.createElement(h,a({ref:n},c))}));function d(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,a=new Array(o);a[0]=f;var u={};for(var s in n)hasOwnProperty.call(n,s)&&(u[s]=n[s]);u.originalType=e,u.mdxType="string"==typeof e?e:i,a[1]=u;for(var l=2;l<o;l++)a[l]=t[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}f.displayName="MDXCreateElement"},8685:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>u,toc:()=>l});var r=t(7462),i=(t(7294),t(3905));const o={},a="Functions",u={unversionedId:"purescript/functions",id:"purescript/functions",title:"Functions",description:"As the name of functional programming suggests it, this style of writing code resolves all around writing functions - so, let's cover what you need to know.",source:"@site/docs/purescript/functions.md",sourceDirName:"purescript",slug:"/purescript/functions",permalink:"/docs/purescript/functions",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/purescript/functions.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"PureScript",permalink:"/docs/category/purescript"},next:{title:"Tutorial - Extras",permalink:"/docs/category/tutorial---extras"}},s={},l=[{value:"Writing a function with a return",id:"writing-a-function-with-a-return",level:3},{value:"Providing types for the function:",id:"providing-types-for-the-function",level:4},{value:"Writing a function with more than one parameter:",id:"writing-a-function-with-more-than-one-parameter",level:3},{value:"Function recursion",id:"function-recursion",level:3},{value:"Higher-order functions",id:"higher-order-functions",level:3},{value:"Impure functions",id:"impure-functions",level:3},{value:"The do-keyword in functions",id:"the-do-keyword-in-functions",level:3}],c={toc:l};function p(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"functions"},"Functions"),(0,i.kt)("p",null,"As the name of functional programming suggests it, this style of writing code resolves all around writing functions - so, let's cover what you need to know. "),(0,i.kt)("h3",{id:"writing-a-function-with-a-return"},"Writing a function with a return"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"double a = a * 2\n")),(0,i.kt)("p",null,'This functions receives a parameter "a" and returns it (everything behind the equals-sign).'),(0,i.kt)("h4",{id:"providing-types-for-the-function"},"Providing types for the function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"double :: Int -> Int\ndouble a = a * 2\n")),(0,i.kt)("p",null,"This is optional, yet, a best practise."),(0,i.kt)("h3",{id:"writing-a-function-with-more-than-one-parameter"},"Writing a function with more than one parameter:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"add :: Int -> Int -> Int\nadd a b = a + b\n")),(0,i.kt)("p",null,"Since functions are curried, just add another Int -> for each parameter.\nThe code, under the hood looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"function add(a) {\n    return function (b) {\n        return a + b\n    }\n}\n")),(0,i.kt)("p",null,"Confusing, hm?"),(0,i.kt)("h3",{id:"function-recursion"},"Function recursion"),(0,i.kt)("p",null,"Recursive is a function that calls itself. This is really useful to write clean code.\nThe following example is a recursive function. It receives a number as starting value,\nand calls the function as long the number is < 10. Of course, this is absolutely useless, because it makes out of any passed number below 10 a 10 as return."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"sumToTen :: Int -> Int\nsumToTen n =\n  if n == 10 then\n    10\n  else\n    sumToTen (n + 1)\n\nmain = log (show (sumToTen 0))\n")),(0,i.kt)("p",null,'Result will be "10".'),(0,i.kt)("h3",{id:"higher-order-functions"},"Higher-order functions"),(0,i.kt)("p",null,"A higher-order function is a function, that takes another function as a parameter / and or returns another function. This might sound weird at first, but trust me, you used higher-order functions before, and the concept is really powerful. For example, map, filter and reduce as we also have them in JavaScript or Python, are higher-order functions. "),(0,i.kt)("p",null,"Let's write a function, that takes another function as a parameter: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"doubleNum :: Int -> Int \ndoubleNum n = n * 2\n\ndivideByTwo :: (Int -> Int) -> Int -> Int \ndivideByTwo fun n = (fun n) / 2 \n")),(0,i.kt)("p",null,'Our divideByTwo function takes a function with the signature (Int -> Int) as the first parameter. In this functions signature, you can see the () - they always mean we expect a function as a parameter. Then, divideByTwo takes a single Integer, and finally returns an integer.\nIn the definition you can see that we take the providied function and call it "fun", then pass n to this function. '),(0,i.kt)("p",null,"Now, let's use the functions: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"divideByTwo doubleNum 4 \n--- 4\n")),(0,i.kt)("p",null,"As we undo the multiplication through dividing, the output is 4 again. "),(0,i.kt)("h3",{id:"impure-functions"},"Impure functions"),(0,i.kt)("p",null,"By definition, pure functions do not change anything outside of their scope. Logging something in the\nconsole therefore is an impure function.\nOf course we can log something from a function, instead of returning a value.\nThis is the case of an impure function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'logSomething :: String -> Effect Unit\nlogSomething message = log ("My message: " <> message)\n\n\nmain = logSomething "Hello"\n')),(0,i.kt)("h3",{id:"the-do-keyword-in-functions"},"The do-keyword in functions"),(0,i.kt)("p",null,'The do keyword allows to make code in functions more readable and to work with different expressions. In the following example, "j" and "i" are both expressions, used in a final expression at the bottom which is finally returned.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"factors :: Int -> Array (Array Int)\nfactors n = filter (\\xs -> product xs == n) do\n  i <- 1 .. n\n  j <- i .. n\n  [ [ i, j ] ]\n")))}p.isMDXComponent=!0}}]);